import { _ as _export_sfc, c as createElementBlock, o as openBlock, a as createStaticVNode } from "./app.22c2e13e.js";
const __pageData = '{"title":"Commands","description":"","frontmatter":{},"headers":[{"level":2,"title":"Command","slug":"command"},{"level":3,"title":"name","slug":"name"},{"level":3,"title":"match","slug":"match"},{"level":3,"title":"description","slug":"description"},{"level":3,"title":"global","slug":"global"},{"level":3,"title":"pageFn","slug":"pagefn"},{"level":3,"title":"nice","slug":"nice"},{"level":3,"title":"fn","slug":"fn"},{"level":3,"title":"enterContext","slug":"entercontext"},{"level":3,"title":"normal","slug":"normal"},{"level":3,"title":"minConfidence","slug":"minconfidence"},{"level":3,"title":"onlyFinal","slug":"onlyfinal"},{"level":3,"title":"delay","slug":"delay"},{"level":3,"title":"activeDocument","slug":"activedocument"},{"level":3,"title":"test","slug":"test"},{"level":3,"title":"fn vs. pageFn","slug":"fn-vs-pagefn"},{"level":2,"title":"DynamicMatch","slug":"dynamicmatch"},{"level":2,"title":"DynamicMatchFnResp","slug":"dynamicmatchfnresp"},{"level":2,"title":"LocalizedCommand","slug":"localizedcommand"},{"level":3,"title":"name","slug":"name-1"},{"level":3,"title":"match","slug":"match-1"},{"level":3,"title":"description","slug":"description-1"},{"level":3,"title":"delay","slug":"delay-1"},{"level":3,"title":"nice","slug":"nice-1"}],"relativePath":"api-reference/command.md"}';
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="commands" tabindex="-1">Commands <a class="header-anchor" href="#commands" aria-hidden="true">#</a></h1><h2 id="command" tabindex="-1">Command <a class="header-anchor" href="#command" aria-hidden="true">#</a></h2><p>Each plugin has a list of commands.</p><p>Also see <a href="/api-reference/command.html#localizedcommand"><code>LocalizedCommand</code></a>.</p><p>Each command has the following properties:</p><h3 id="name" tabindex="-1">name <a class="header-anchor" href="#name" aria-hidden="true">#</a></h3><ul><li>Type: <code>string</code></li></ul><p>Friendly-name of the command (not necessarily the words used to call it). Should be title-cased.</p><h3 id="match" tabindex="-1">match <a class="header-anchor" href="#match" aria-hidden="true">#</a></h3><ul><li>Type: <code>string | string[] | </code><a href="/api-reference/command.html#dynamicmatch"><code>DynamicMatch</code></a></li></ul><p>The word(s) the user can say to execute this command. <br><br>Make sure it&#39;s completely lowercase and without any punctuation. Use &quot;#&quot; in the string as an ordinal place holder. Use &quot;*&quot; as a wildcard placeholder. Lastly, a function <a href="/api-reference/command.html#dynamicmatch"><code>DynamicMatch</code></a> can be used for the most advanced cases</p><h3 id="description" tabindex="-1">description <a class="header-anchor" href="#description" aria-hidden="true">#</a></h3><ul><li>Optional</li><li>Type: <code>string</code></li></ul><p>Detailed description visible in the options page.</p><h3 id="global" tabindex="-1">global <a class="header-anchor" href="#global" aria-hidden="true">#</a></h3><ul><li>Type: <code>boolean</code></li><li>Default: <code>false</code></li></ul><p>Let the command work on any page (not restricted by the <code>match</code> of the Plugin).</p><h3 id="pagefn" tabindex="-1">pageFn <a class="header-anchor" href="#pagefn" aria-hidden="true">#</a></h3><ul><li>Optional</li><li>Type: <code>(transcript: TsData, ...matchOutput: any) =&gt; Promise&lt;void&gt;</code></li></ul><p>An async function to run on the page when the command is called. Special matches (<code>*</code> and <code>#</code>) will be arguments after the transcript string argument, and will come in the order they are specified in the match property. <code>rawTranscript</code> is the transcript before trimming, lowercasing, removing hyphens, and other special characters. There will be a number argument if the match string accepts an ordinal (eg. has a <code>#</code>) in it, or a string argument if the match string accepts a wildcard (eg. has a <code>*</code> in it).<br><br>Optionally resolve the promise when this function is finished to help chaining work. Eg. we can use <code>return await PluginBase.util.sleep(500);</code> if we know a command will take no longer than 500ms to finish, and to only execute the next command in the chain after that 500ms delay.<br><br> Also see <a href="/api-reference/command.html#fn-vs-pagefn">fn vs. pageFn</a></p><h3 id="nice" tabindex="-1">nice <a class="header-anchor" href="#nice" aria-hidden="true">#</a></h3><ul><li><p>Optional</p></li><li><p>Type: <a href="/api-reference/command.html#nicecommand"><code>NiceCommand</code></a></p><p>See <a href="/api-reference/command.html#nicecommand"><code>NiceCommand</code></a>.</p></li></ul><h3 id="fn" tabindex="-1">fn <a class="header-anchor" href="#fn" aria-hidden="true">#</a></h3><ul><li>Optional</li><li>Type: <code>(transcript: TsData, ...matchOutput: any) =&gt; Promise&lt;void&gt;</code></li></ul><p>An async function that runs in the Chrome extension context when the command is called. First arg is the transcript that matched, rest of arguments are what&#39;s returned from the match command. <br><br>Resolve this promise when the command is done executing in order for chaining to work properly (if desired).<br><br> Also see <a href="/api-reference/command.html#fn-vs-pagefn">fn vs. pageFn</a>.</p><h3 id="entercontext" tabindex="-1">enterContext <a class="header-anchor" href="#entercontext" aria-hidden="true">#</a></h3><ul><li>Optional</li><li>Type: <code>string</code></li></ul><p>What context to enter if this command matches.</p><p>This is a sugar for writing:</p><div class="language-ts"><pre><code><span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> PluginBase<span class="token punctuation">.</span>util<span class="token punctuation">.</span><span class="token function">enterContext</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>\n</code></pre></div><p>See <a href="/contexts.html">Contexts</a> for details.</p><h3 id="normal" tabindex="-1">normal <a class="header-anchor" href="#normal" aria-hidden="true">#</a></h3><ul><li>Type: <code>boolean</code></li><li>Default: <code>true</code></li></ul><p>Make <code>false</code> if you don&#39;t wan&#39;t this command included in the &quot;Normal&quot; (default) context.</p><p>See <a href="/contexts.html">Contexts</a> for details.</p><h3 id="minconfidence" tabindex="-1">minConfidence <a class="header-anchor" href="#minconfidence" aria-hidden="true">#</a></h3><ul><li>Optional</li><li>Type: <code>number</code></li></ul><p>A decimal between 0.0 and 1.0 that specifies the minimum confidence needed for this command to be considered a match. <br><br> Useful for lowering sensitivity of specific commands if they are relatively &quot;dangerous&quot; to execute, for example.</p><p>See also <code>onlyFinal</code>.</p><h3 id="onlyfinal" tabindex="-1">onlyFinal <a class="header-anchor" href="#onlyfinal" aria-hidden="true">#</a></h3><ul><li>Optional</li><li>Type: <code>true</code></li><li>Default: <code>false</code></li></ul><p>Only execute the command if it&#39;s the final transcript (not a partial, interim transcript that comes in as best current guess). Especially useful for commands with wildcards where we don&#39;t want to execute prematurely with an early guess.</p><p>See also <code>minConfidence</code>.</p><h3 id="delay" tabindex="-1">delay <a class="header-anchor" href="#delay" aria-hidden="true">#</a></h3><ul><li>Optional</li><li>Type: <code>number | number[]</code></li></ul><p>How long to wait for additional input for before executing this command. Overrides delay that is built-in for commands with match strings that end in ordinals or wildcards. <br><br> Useful for when you want to allow time for more words to come through. <br><br> Use an array with indices that correspond to the different match strings if you should have different delays based on the match string.<br><br>Use 0 to override dynamically calculated delay and to execute command immediately on match.</p><h3 id="activedocument" tabindex="-1">activeDocument <a class="header-anchor" href="#activedocument" aria-hidden="true">#</a></h3><ul><li>Type: <code>boolean</code></li><li>Default: <code>false</code></li></ul><p>Whether to execute this command in the focused frame or iFrame. Won&#39;t work if the final focus is document.body.</p><h3 id="test" tabindex="-1">test <a class="header-anchor" href="#test" aria-hidden="true">#</a></h3><ul><li>Optional</li><li>Type: <code>(t: ExecutionContext&lt;CommandTestContext&gt;, say: (s?: string) =&gt; Promise&lt;void&gt;, client: WebdriverIO.Browser) =&gt; void</code></li></ul><p><a href="https://github.com/avajs/ava">AVA</a> integration test for this command.</p><h3 id="fn-vs-pagefn" tabindex="-1"><code>fn</code> vs. <code>pageFn</code> <a class="header-anchor" href="#fn-vs-pagefn" aria-hidden="true">#</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>pageFn</code> runs in the context of the page so it has access to the DOM, but doesn&#39;t have access to Chrome extension APIs like <code>chrome.tabs</code>. <code>fn</code> on the other hand runs in the (sandboxed) context of the Chrome extension; it doesn&#39;t have access to the page or it&#39;s DOM but it does have access to the Chrome extension APIs.</p></div><h2 id="dynamicmatch" tabindex="-1">DynamicMatch <a class="header-anchor" href="#dynamicmatch" aria-hidden="true">#</a></h2><ul><li>Type: <code>{description: string, fn: (transcript: string) =&gt; </code><a href="/api-reference/command.html#dynamicmatchfnresp"><code>DynamicMatchFnResp</code></a><code> }</code></li></ul><p>A function and it&#39;s description. The function decides whether a command matches based on a transcript input for more dynamic command word possibilities. Returns non-void if the command should execute on the given transcript. The description is used to inform the user what command words match. It&#39;s seen in plugins list in the LipSurf options, and in the help.</p><h2 id="dynamicmatchfnresp" tabindex="-1">DynamicMatchFnResp <a class="header-anchor" href="#dynamicmatchfnresp" aria-hidden="true">#</a></h2><ul><li>Type: <code>[startMatchIndex: number, endMatchIndex: number, matchOutput?: any[]] | false | undefined</code> (or a <code>Promise</code> with the same result type).</li></ul><p>The start match index, the end match index and an array of <code>any</code> type args to pass over to <code>pageFn</code> as the <code>...matchOutput: any[]</code> arguments. Don&#39;t include the transcript argument, as it&#39;s automatically included (and trimmed depending on the start and end match indices).</p><div class="tip custom-block"><p class="custom-block-title">When to return false</p><p>Return <code>false</code> or <code>Promise&lt;false&gt;</code> if there is a partial match. If there is a partial match we will delay other commands that might already want to execute.</p><p>For example, imagine there&#39;s a command word for <span class="voice-cmd">reddit</span> and a <a href="/api-reference/command.html#dynamicmatch">dynamic match command</a> for <span class="voice-cmd">reddit message</span> that are both valid on a given page. If the user says <span class="voice-cmd">reddit message</span> the transcripts will come down the wire something like this:</p><ul><li>red</li><li>reddit</li><li>read it</li><li>read it mess</li><li>reddit mess</li><li>reddit message</li></ul><p>Can you see the problem? Our &quot;reddit&quot; command will execute even though we only want &quot;reddit&quot; message to.</p><p>If you don&#39;t want the first &quot;reddit&quot; command to match, return <code>false</code> when there is a partial match for the dynamic <span class="voice-cmd">reddit</span> command for transcripts that start with &quot;reddit&quot;.</p></div><h2 id="localizedcommand" tabindex="-1">LocalizedCommand <a class="header-anchor" href="#localizedcommand" aria-hidden="true">#</a></h2><p>See also <a href="/api-reference/command.html#command"><code>Command</code></a> and <a href="/api-reference/plugin.html#localizedplugin"><code>LocalizedPlugin</code></a>.</p><h3 id="name-1" tabindex="-1">name <a class="header-anchor" href="#name-1" aria-hidden="true">#</a></h3><ul><li>Type: <code>string</code></li></ul><p>The original name of the command to match this localized version with.</p><h3 id="match-1" tabindex="-1">match <a class="header-anchor" href="#match-1" aria-hidden="true">#</a></h3><ul><li>Type: <code>string | string[] | </code><a href="/api-reference/command.html#dynamicmatch"><code>DynamicMatch</code></a></li></ul><p>A localized command can match in a way independent from the base (en) command.</p><h3 id="description-1" tabindex="-1">description <a class="header-anchor" href="#description-1" aria-hidden="true">#</a></h3><ul><li>Optional</li><li>Type: <code>string</code></li></ul><h3 id="delay-1" tabindex="-1">delay <a class="header-anchor" href="#delay-1" aria-hidden="true">#</a></h3><ul><li>Optional</li><li>Type: <code>number | number[]</code></li></ul><p>Delays for a localized version of a command can be completely different from the base English version.</p><h3 id="nice-1" tabindex="-1">nice <a class="header-anchor" href="#nice-1" aria-hidden="true">#</a></h3><ul><li>Optional</li><li>Type: <code>string | ((transcript: TsData, ...matchOutput: any[]) =&gt; string)</code></li></ul><p>Sometimes we want to adjust the transcript as it is shown on the live transcript. For example if the user says <span class="voice-cmd">go to are meal time videos</span> we would want to show that as <span class="voice-cmd">go to r/mealtimevideos</span>.</p><p>Returns the complete &quot;live transcript&quot; that should be shown. <code>rawInput</code> is the transcript (eg. &quot;go to are meal time videos&quot;) <code>matchOutput</code> is an array returned from the match command if <a href="/api-reference/command.html#dynamicmatch"><code>DynamicMatch</code></a>is used.</p>', 78);
const _hoisted_79 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_79);
}
var command = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { __pageData, command as default };
